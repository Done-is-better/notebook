<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
  <head>
    <title></title>
    <dateModified></dateModified>
    <ownerName></ownerName>
  </head>
  <body>
<outline text="7.1 Spring Security介绍" _note="&gt; Spring Security&#10;&gt; 是一个基于Spring生态圈，用于提供安全访问控制解决方案的框架。Spring&#10;&gt; Boot 对Spring Security&#10;&gt; 提供了整合支持，并提供了通用的自动化配置，从而实现了Spring Security&#10;&gt; 安全框架中包含的多数安全管理功能。&#10;&#10;    &lt;dependency&gt;&#10;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;                &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&#10;            &lt;/dependency&gt;">
</outline>
<outline text="7.3 &lt;a&gt;MVC Security&lt;/a&gt; 安全配置" _note="&gt; 使用Spring Boot 与Spring MVC&#10;&gt; 进行web开发时，如果项目引入spring-boot-starter-security&#10;&gt; 依赖启动器，MVC Security&#10;&gt; 安全管理功能就会自动生效，其默认的安全配置是在SecurityAutoConfiguration&#10;&gt; 会导入并自动化配置SpringBootWebSecurityConfiguration 用于启动web&#10;&gt; 安全管理，UserDetailsServiceAutoConfiguration 则用于配置用户身份信息。&#10;&gt;&#10;&gt; 要完全关闭Security 提供的&#10;&gt; web应用默认安全配置，可以自定义WebSecurityConfigurerAdapter&#10;&gt; 类型的Bean组件。但是不会关闭UserDetailsService&#10;&gt; 用户信息自动配置类。如果要关闭UserDetailsService&#10;&gt; 默认的用户信息配置，可以自定义UserDetailsService、AuthenticationProvider或&#10;&gt; AuthenticationManager&#10;&gt; 类型的Bean组件。另外，可以通过自定义WebSecurityConfigurerAdapter&#10;&gt; 类型的Bean组件来覆盖默认访问规则。Spring Boot&#10;&gt; 提供了多种方法，可用于覆盖请求映射和静态资源的访问规则。&#10;&gt;&#10;&gt; **WebSecurityConfigurerAdapter类的主要方法**&#10;&gt;&#10;&gt; [TABLE]">
</outline>
<outline text="7.4 自定义用户认证" _note="&gt; 通过自定义WebSecurityConfigurerAdapter&#10;&gt; 类型的Bean组件，并重写configure(AuthenticationManagerBuilder auth)&#10;&gt; 方法可以自定义用户认证。针对自定义用户认证，Spring Security&#10;&gt; 提供了多种自定义认证方式，包括有In-Memory&#10;&gt; Authentication(内存身份认证)、JDBC Authentication(JDBC身份认证)、LDAP&#10;&gt; Authentication(LDAP身份认证)、AuthenticationProvider(身份认证提供商)和UserDetailsService(身份详情服务)&#10;&gt; .">
  <outline text="7.4.1 内存身份认证" _note="&gt; In-Memory Authentication(内存身份认证)&#10;&gt; 是最简单的身份认证方式，主要用于Security 安全认证体验和测试。&#10;&gt;&#10;&gt; 自定义身份认证时，只需要在重写的configure(AuthenticationManagerBuilder&#10;&gt; auth) 方法中定义测试用户即可。&#10;&#10;1.  自定义WebSecurityConfigurerAdapter 配置类&#10;&#10;&amp;nbsp;&#10;&#10;    @EnableWebSecurity&#10;    public class SecurityConfig extends WebSecurityConfigurerAdapter {&#10;        protected void configure(AuthenticationManagerBuilder auth)throws Exception{&#10;            //设置密码编码器&#10;            BCryptPasswordEncoder b = new BCryptPasswordEncoder();&#10;            //模拟测试用户&#10;            InMemoryUserDetailsManagerConfigurer&lt;AuthenticationManagerBuilder&gt;&#10;                    a = auth.inMemoryAuthentication().passwordEncoder(b);&#10;            a.withUser(&quot;shitou&quot;).password(b.encode(&quot;123&quot;)).roles(&quot;comment&quot;);&#10;            InMemoryUserDetailsManagerConfigurer&lt;AuthenticationManagerBuilder&gt; au = auth.inMemoryAuthentication().passwordEncoder(b);&#10;            au.withUser(&quot;chandler&quot;).password(b.encode(&quot;1234&quot;)).roles(&quot;VIP&quot;);&#10;        }&#10;    }&#10;&#10;&gt; **@EnableWebSecurity** 注解是一个组合注解，主要包括：&#10;&gt;&#10;&gt; *@Configuration* :作用是将当前自定义的SecurityConfig 类作为Spring Boot&#10;&gt; 的配置类&#10;&gt;&#10;&gt; *@Import({WebSecurityConfiguration.class,Spring&#10;&gt; WebMvcImportSelector.class})* :作用是根据pom.xml中导入的Web&#10;&gt; 模板和Security模块进行自动化配置&#10;&gt;&#10;&gt; *@EnableGoobalAuthentication* ：用于开启自定义的全局认证。">
  </outline>
  <outline text="7.4.2 &lt;a&gt;JDBC&lt;/a&gt;身份认证" _note="&gt; JDBC Authentication(JDBC身份认证) 是通过JDBC&#10;&gt; 连接数据库进行已有用户身份认证，避免了内存身份认证的弊端，可以实现对已注册用户的身份认证。&#10;&#10;1.  添加依赖&#10;&#10;&amp;nbsp;&#10;&#10;     &lt;dependency&gt;&#10;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;                &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&#10;            &lt;/dependency&gt;&#10;            &lt;dependency&gt;&#10;                &lt;groupId&gt;mysql&lt;/groupId&gt;&#10;                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&#10;                &lt;scope&gt;runtime&lt;/scope&gt;&#10;            &lt;/dependency&gt;&#10;&#10;    @EnableWebSecurity&#10;    public class SecurityConfig extends WebSecurityConfigurerAdapter {&#10;        @Qualifier(&quot;dataSource&quot;)&#10;        @Autowired&#10;        private DataSource dataSource;&#10;        protected void configure(AuthenticationManagerBuilder auth)throws Exception{&#10;            //设置密码编码器&#10;            BCryptPasswordEncoder b = new BCryptPasswordEncoder();&#10;&#10;                    //使用JDBC进行身份认证&#10;                    JdbcUserDetailsManagerConfigurer&lt;AuthenticationManagerBuilder&gt; a = auth.jdbcAuthentication().passwordEncoder(b);&#10;                    a.usersByUsernameQuery(&quot;select username,password,valid from t_customer where username =?&quot;);&#10;                    a.authoritiesByUsernameQuery(&quot;select c.username,a.authority from t_customer c,t_authority a,t_customer_authority ta where c.id=ta.customer_id and a.id = ta.authority_id and c.username = ?&quot;);">
  </outline>
  <outline text="7.4.3 &lt;a&gt;UserDetailsService&lt;/a&gt;身份认证" _note="&gt; 对于用户流量较大的项目，频繁的使用JDBC&#10;&gt; 进行数据库查询，会降低网站登录访问速度。&#10;&#10;...">
  </outline>
  <outline text="7.4.4 自定义用户访问控制" _note="通过重写WebSecurityConfigurerAdapter 类的configure(HttpSecurity http)&#10;方法可以对基于HTTP的请求访问进行控制。&#10;&#10;&gt; HttpSecurity 类的主要方法&#10;&#10;[TABLE]&#10;&#10;&gt; authorizeRequests() 方法返回值&#10;&#10;[TABLE]">
  </outline>
  <outline text="7.4.5 自定义用户登录">
    <outline text="用户登录相关方法" _note="[TABLE]&#10;&#10;1.  定义视图&#10;&#10;&amp;nbsp;&#10;&#10;    &lt;form th:action=&quot;@{/userlogin}&quot; th:method=&quot;post&quot;&gt;&#10;          &lt;h1&gt;请登录&lt;/h1&gt;&#10;          &lt;div th:if=&quot;${param.error}&quot;&gt;用户名或密码错误，请重新登陆&lt;/div&gt;&#10;          &lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;用户名&quot;/&gt;&#10;          &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;/&gt;&#10;          &lt;div&gt;&#10;            &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;rememberme&quot;/&gt;记住我&lt;/label&gt;&#10;          &lt;/div&gt;&#10;          &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;&#10;          &lt;p&gt;@Copyright 2019-2022&lt;/p&gt;&#10;        &lt;/form&gt;&#10;&#10;1.  自定义用户登录跳转&#10;&#10;&amp;nbsp;&#10;&#10;    //Spring Security默认使用get方式的&quot;/login&quot;请求用于向登录页面跳转，默认使用post方式&quot;/login&quot;请求用于对登陆后的数据进行处理&#10;    @RequestMapping(value=&quot;/userlogin&quot;)&#10;        public String toLoginPage(){&#10;            return &quot;login&quot;;&#10;        }&#10;&#10;1.  自定义用户登录控制&#10;&#10;&amp;nbsp;&#10;&#10;    protected void configure(HttpSecurity http) throws Exception{&#10;        http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()//对&quot;/&quot;路径放行&#10;            .antMatchers(&quot;/**&quot;).permitAll()&#10;            .antMatchers(&quot;/details/common/**&quot;).hasRole(&quot;common&quot;)//对&quot;/details/common/&quot;路径的请求，需要common权限，即ROLE_common&#10;            .antMatchers(&quot;/details/vip/**&quot;).hasRole(&quot;vip&quot;)&#10;            .anyRequest().autenticated() //未映射的请求必须登录认证&#10;            .and().formLogin();	//配置类Security默认登录页面&#10;        //自定义用户登录控制&#10;        http.formLogin().loginPage(&quot;/userLogin&quot;).permitAll()&#10;            .usernameParameter(&quot;name&quot;)&#10;            .passwordParameter(&quot;password&quot;)&#10;            .defaultSuccessUrl(&quot;/&quot;)&#10;            .failureUrl(&quot;/userLogin?error&quot;);&#10;    }">
    </outline>
  </outline>
  <outline text="7.5.3 自定义用户退出" _note="自定义用户退出主要考虑退出后会话如何管理以及跳转到那个页面，HttpSecurity&#10;类的logout()方法用来处理用户退出，默认的处理路径为&quot;/logout&quot;&#10;的post请求，同时会清除Session和 Rememberme等任何默认用户配置。&#10;&#10;用户退出涉及到用户推出的主要方法&#10;&#10;[TABLE]&#10;&#10;&gt; **注意**&#10;&gt;&#10;&gt; Spring Boot 项目中引入Spring Security 框架后会自动 开启CSRF&#10;&gt; 防护功能（请求跨站伪造防护），用户退出是必须使用post请求。如果关闭了CSRF&#10;&gt; 防护功能，可以使用任意方式的HTTP请求进行用户注销。&#10;&#10;    &lt;form th:action=&quot;@{/logout}&quot; method=&quot;post&quot;&gt;&#10;        &lt;button type=&quot;submit&quot;&gt;退出&lt;/button&gt;&#10;    &lt;/form&gt;&#10;&#10;    http.logout().logoutUrl(&quot;/logout&quot;).logoutSuccessUrl(&quot;/logoutSuccess&quot;);">
  </outline>
  <outline text="7.5.4 登录用户信息获取" _note="在传统项目中进行用户登录时，通常会查询用户是否存在，如果存在就登录成功，同时将当前用户放在Session中。&#10;&#10;1.  使用HttpSession获取用户信息&#10;&#10;&amp;nbsp;&#10;&#10;    @GetMapping(&quot;/&quot;)&#10;    @ResponseBody&#10;    public void getUser(HttpSession session){&#10;        //从当前HttpSession获取绑定到词汇化的所有对象的名称&#10;        Enumeration&lt;String&gt; names = session.getAttributeNames();&#10;        while(names.hasMoreElements()){&#10;            //获取HttpSession中会话名称&#10;            String element = names.nextElement();&#10;            //获取HttpSession中的应用上下文&#10;            SecurityContextImpl attribute = (SecurityContextImpl) session.getAttribute(element);&#10;            //获取用户相关信息&#10;            Authentication authentication = attribute.getAuthentication();&#10;            UserDetails principal = (UserDetails) authentication.getPrincipal();&#10;            &#10;        }&#10;    }&#10;&#10;1.  使用SecurityContextHolder获取用户信息&#10;&#10;&amp;nbsp;&#10;&#10;    @RequestMapping(&quot;/getUser&quot;)&#10;    public @ResponseBody getUser(){&#10;        SecurityContext context = SecurityContextHolder.getContext();&#10;        Authentication authentication  = context.getAuthentication();&#10;        UserDetails principal = (UserDetails) authentication.getPrincipal();&#10;        System.out.println(principal.getUsername());&#10;    }">
  </outline>
  <outline text="7.5.5 RememberMe" _note="rememberme&#10;&#10;[TABLE]&#10;&#10;&gt; Spring Security 针对Remember-me&#10;&gt; 提供了两种实现：一种是简单的使用加密来保证基于cookie中Token的安全；另一种是通过数据或其他持久化机制来保存生成的Token&#10;&#10;一。基于简单加密的Token的方式&#10;&#10;&gt; 基于简单加密的Token方式，当用户选择Remember-me并成功登陆后，Spring&#10;&gt; Security&#10;&gt; 会生成一个cookie并发送给客户端浏览器。其中，cookie值由以下方式组合加密而成：&#10;&gt;&#10;&gt;     base64(username+&quot;:&quot;+expirationTime+&quot;:&quot;+md5Hex(username + &quot;:&quot;+expirationTime+&quot;:&quot;+password +&quot;:&quot;+key))&#10;&gt;     //expirationTime表示rememberMe中Token的实效日期，以毫秒为单位，key 表示防止修改Token地标识。&#10;&gt;&#10;&gt; 基于简单加密的Token的方式中的Token在指定时间内有效，且必须保证Token中包含的username，password和key没有被改变。但这种加密方式是存在隐患的，任何人获取到该RememberMe功能的Token后，都可以在该Token过期之前自动登录，只有当前用户察觉Token被盗后，才会对自己登录密码进行修改来立即使原有的Token实效。&#10;&#10;    package com.szjm.itheimachapter07.config;&#10;&#10;    import org.springframework.beans.factory.annotation.Autowired;&#10;    import org.springframework.beans.factory.annotation.Qualifier;&#10;    import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;&#10;    import org.springframework.security.config.annotation.authentication.configurers.provisioning.InMemoryUserDetailsManagerConfigurer;&#10;    import org.springframework.security.config.annotation.authentication.configurers.provisioning.JdbcUserDetailsManagerConfigurer;&#10;    import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;    import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;&#10;    import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#10;&#10;    import javax.sql.DataSource;&#10;&#10;    /**&#10;     * @author chixinyu&#10;     * @version 2021/11/20 19:45&#10;     */&#10;&#10;    @EnableWebSecurity&#10;    public class SecurityConfig extends WebSecurityConfigurerAdapter {&#10;        @Qualifier(&quot;dataSource&quot;)&#10;        @Autowired&#10;        private DataSource dataSource;&#10;    protected void configure(HttpSecurity http) throws Exception{&#10;        http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()&#10;                .antMatchers(&quot;/**&quot;).permitAll()&#10;                .antMatchers(&quot;/details/common/**&quot;).hasRole(&quot;common&quot;)&#10;                .antMatchers(&quot;/details/vip/**&quot;).hasRole(&quot;vip&quot;)&#10;                .anyRequest().authenticated()&#10;                .and().formLogin();&#10;        //自定义用户登录控制&#10;        http.formLogin().loginPage(&quot;/userlogin&quot;).permitAll()&#10;                .usernameParameter(&quot;name&quot;)&#10;                .passwordParameter(&quot;password&quot;)&#10;                .defaultSuccessUrl(&quot;/&quot;)&#10;                .failureUrl(&quot;/userlogin?error&quot;);&#10;        http.logout().logoutUrl(&quot;/logout&quot;).logoutSuccessUrl(&quot;/logoutSuccess&quot;);&#10;        //rememberme&#10;        http.rememberMe().rememberMeParameter(&quot;rememberme&quot;).tokenValiditySeconds(200);&#10;    }&#10;    }&#10;&#10;二。基于持久化Token的方式&#10;&#10;&gt; 持久化Token的方式与简单加密Token的方式在实现Remember-Me功能上大体相同，都是在用户选择“记住我”功能并成功登陆后，将生成的Token存入cookie中并发送到客户端浏览器，在下次用户通过统一客户端访问系统时，系统将直接从客户端cookie中读取Token进行认证。两者的主要区别在于：基于简单加密Token的方式，生成的Token将在客户端保存一段时间，如果用户不退出登录，或不修改密码，在cookie失效之前，任何人都可以使用该cookie进行登录；二基于持久化Token的方式：&#10;&gt;&#10;&gt; 1.  用户选择“记住我”成功登陆后，Security会把username、随机产生的序列号、生成的Token进行持久化存储，同时将他们组合生成一个cookie发送给客户端浏览器。&#10;&gt;&#10;&gt; 2.  当用户再次访问系统时，首先检查客户端携带的cookie，如果对应cookie中包含的username、序列号和Token与数据库保存的一致，则通过验证并自动登录，同时系统将重新生成一个新的Token替换数据库中旧的Token，并将新的cookie再次发送给客户端。&#10;&gt;&#10;&gt; 3.  如果cookie中的Token不匹配，则可能是用户的cookie被盗用了。由于盗用者使用初次生成的Token进行登录会生成一个新的Token和cookie。同时Spring&#10;&gt;     Security&#10;&gt;     可以发现cookie可能被到用的情况，它将删除数据库中与当前用户相关的所有Token记录&#10;&gt;     ，这样盗用者使用原有的cookie将不能再次登录。&#10;&gt;&#10;&gt; 4.  如果用户访问系统是没有携带cookie，或者包含的username和序列号与数据库中保存的不一致，那么将会引导用户到登录页面。&#10;&#10;    package com.szjm.itheimachapter07.config;&#10;&#10;&#10;    @EnableWebSecurity&#10;    public class SecurityConfig extends WebSecurityConfigurerAdapter {&#10;        @Qualifier(&quot;dataSource&quot;)&#10;        @Autowired&#10;        private DataSource dataSource;&#10;      &#10;    protected void configure(HttpSecurity http) throws Exception{&#10;        http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()&#10;                .antMatchers(&quot;/**&quot;).permitAll()&#10;                .antMatchers(&quot;/details/common/**&quot;).hasRole(&quot;common&quot;)&#10;                .antMatchers(&quot;/details/vip/**&quot;).hasRole(&quot;vip&quot;)&#10;                .anyRequest().authenticated()&#10;                .and().formLogin();&#10;        //自定义用户登录控制&#10;        http.formLogin().loginPage(&quot;/userlogin&quot;).permitAll()&#10;                .usernameParameter(&quot;name&quot;)&#10;                .passwordParameter(&quot;password&quot;)&#10;                .defaultSuccessUrl(&quot;/&quot;)&#10;                .failureUrl(&quot;/userlogin?error&quot;);&#10;        http.logout().logoutUrl(&quot;/logout&quot;).logoutSuccessUrl(&quot;/logoutSuccess&quot;);&#10;        //rememberme&#10;        http.rememberMe().rememberMeParameter(&quot;rememberme&quot;)&#10;                .tokenValiditySeconds(200)&#10;                .tokenRepository(tokenRepository());&#10;    }&#10;        @Bean&#10;        public JdbcTokenRepositoryImpl tokenRepository(){&#10;            JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();&#10;            jdbcTokenRepository.setDataSource(dataSource);&#10;            return jdbcTokenRepository;&#10;        }&#10;    }">
  </outline>
  <outline text="7.5.6 CSRF 防护功能" _note="&gt; CSRF(Cross-site request forgery) 跨站请求伪造，也称为One Click Attack&#10;&gt; 或Session Riding(会话控制) 通常缩写成CSRF 或 XSRF&#10;&gt; ，是一种对网站的恶意利用。与传统的XSS 攻击(Cross-site-Scripting)&#10;&gt; 相比，CSRF攻击更难防范，被认为是比XSS更具危险性。&#10;&gt;&#10;&gt; CSRF攻击可以在受害者毫不知情的情况下以受害者的名义伪造请求发送攻击页面，从而在用户未授权的情况下执行在权限保护下的操作。&#10;&gt;&#10;&gt; 针对CSRF攻击要保护的对象是那些可以直接产生数据变化的服务，而对于读取数据的服务，可以不进行CSRF保护。&#10;&gt;&#10;&gt; 目前防御CSRF攻击主要由三种策略：&#10;&gt;&#10;&gt; 1.  验证HTTP Referer字段&#10;&gt;&#10;&gt; 2.  在请求地址中添加Token并验证&#10;&gt;&#10;&gt; 3.  在HTTP头中自定义属性并验证。&#10;&#10;CSRF防御相关方法&#10;&#10;[TABLE]&#10;&#10;&gt; Spring Boot 整合 Spring&#10;&gt; Security默认开启了CSRF防御功能，并要求数据修改的请求方法都需要经过Security配置的安全认证后方可正常访问，否则无法正常发送请求。&#10;&#10;&gt; 关闭Spring Security 默认开启的CSRF防御功能&#10;&gt;&#10;&gt;     http.csrf().disable();&#10;&#10;1.  针对Form表单数据修改CSRF Token配置&#10;&#10;&amp;nbsp;&#10;&#10;    //Security 支持在Form表单中提交一个携带CSRF Token信息的隐藏域，与其他表单一起提交，这样后台就可以获取并验证该请求是否是安全的。&#10;    &lt;form th:action=&quot;@{/updateUser}&quot; method=&quot;post&quot;&gt;&#10;          &lt;input type=&quot;hidden&quot; th:name=&quot;${_csrf.parameterName}&quot; th:value=&quot;${_csrf.token}&quot;/&gt;  &#10;          用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&#10;          密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&#10;          &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&#10;      &lt;/form&gt;&#10;    &lt;!--Form表单中&lt;input&gt;隐藏标签携带了Security提供的CSRF Token信息。其中，th:name=&quot;${_csrf.parameterName}&quot;会获取Security默认提供的CSRF Token对应的key值_scrf,th:value=&quot;${_csrf.token}&quot;会获取Security默认随机生成的CSRF Token对应的value值。在Form表单中添加上面配置后，无需其他配置就可以正常实现数据修改请求，后台配置的Security会自动欧冠获取并识别请求中的CSRF Token信息并进行用户信息验证。--&gt;&#10;    &lt;!--除此之外，还可以使用Thymeleaf模板的th:action属性配置CSRF Token信息--&gt;&#10;    &lt;form th:action=&quot;@{/updateUser}&quot; method=&quot;post&quot;&gt; &#10;          用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&#10;          密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&#10;          &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&#10;      &lt;/form&gt;&#10;    &lt;!--使用thymeleaf模板的th:action属性配置请求时，会默认携带CSRF Token信息，无需开发者手动添加--&gt;&#10;&#10;    @RequestMapping(value=&quot;/updateUser&quot;)&#10;        public @ResponseBody String update(@RequestParam String username, @RequestParam String password,&#10;                                           @RequestParam(required=false)HttpServletRequest request){//@RequsetParam默认required是false ，即必传的&#10;            System.out.println(&quot;username&quot;+username);&#10;            System.out.println(&quot;password&quot;+password);&#10;            return &quot;update&quot;;&#10;        }&#10;&#10;1.  针对Ajax数据修改请求的CSRF Token配置&#10;&#10;对于Ajax类型的数据修改请求来说，Security提供了通过添加Http header&#10;头信息的方式携带CSRF Token 信息进行请求验证。&#10;&#10;    &lt;!--首先在页面&lt;head&gt;标签中添加&lt;meta&gt;字标签，并配置CSRF Token信息--&gt;&#10;    &lt;head&gt;&#10;        &lt;!--获取CSRF Token--&gt;&#10;        &lt;meta name=&quot;_csrf&quot; th:content=&quot;${_csrf.token}&quot;/&gt;&#10;        &lt;!--获取CSRF 头，默认为X-CSRF-TOKEN--&gt;&#10;        &lt;meta name=&quot;_csrf_header&quot; th:content=&quot;_csrf.headerName&quot;/&gt;&#10;    &lt;/head&gt;&#10;    &lt;!--上述代码中，在&lt;head&gt;标签中添加了两个&lt;meta&gt;字标签，分别来设置CSRF Token信息的属性头和具体生成的Security Token值信息。其中，在HTTP header头信息中携带的CSRF请求头header参数的默认值为X-CSRF-TOKEN,而请求头CSRF header对应的CSRF Token值也是随机生成的。--&gt;&#10;&#10;    &lt;!--然后，在具体的Ajax请求中获取&lt;meta&gt;字标签中设置的CSRF Token信息并绑定在HTTP请求头中进行请求验证--&gt;&#10;    $(function(){&#10;    	&lt;!--获取&lt;meta&gt;标签中封装的CSRF Token信息--&gt;&#10;    	var token = $(&quot;meta[name='_csrf']&quot;).attr(&quot;content&quot;);&#10;    	var header = $(&quot;meta[name='_csrf_header']&quot;).attr(&quot;content&quot;);&#10;    	&lt;!--将头中的CSRF Token信息进行发送--&gt;&#10;    	$(document).ajaxSend(function(e,xhr,options){&#10;    		xhr.setRequestHeader(header,token);&#10;    });&#10;    });">
  </outline>
  <outline text="7.6 Security管理前端页面" _note="1.  添加依赖&#10;&#10;&amp;nbsp;&#10;&#10;    &lt;dependency&gt;&#10;    	&lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;&#10;        &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;&#10;    &lt;/dependency&gt;&#10;&#10;1.  使用Security 相关标签进行页面控制&#10;&#10;&amp;nbsp;&#10;&#10;    &lt;!DOCTYPE html&gt;&#10;    &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&#10;    &lt;head&gt;&#10;        &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;        &lt;title&gt;Title&lt;/title&gt;&#10;    &lt;/head&gt;&#10;    &lt;body&gt;&#10;    &lt;div sec:authorize=&quot;isAnonymous()&quot;&gt;&#10;      &lt;h2&gt;&#10;        请登录&#10;      &lt;/h2&gt;&#10;    &lt;/div&gt;&#10;    &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;&#10;      &lt;span sec:authentication=&quot;name&quot; &gt;&lt;/span&gt;,您好 您的权限为  &lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt;&#10;      &lt;form th:action=&quot;@{/mylogout}&quot; method=&quot;post&quot;&gt;&#10;        &lt;input th:type=&quot;submit&quot; th:value=&quot;注销&quot;/&gt;&#10;      &lt;/form&gt;&#10;    &lt;/div&gt;&#10;    &lt;hr/&gt;&#10;    &lt;div sec:authorize=&quot;hasRole('common')&quot;&gt;&#10;      &lt;h3&gt;&#10;        普通电影&#10;      &lt;/h3&gt;&#10;      &lt;ul&gt;&#10;        &lt;li&gt;&lt;a th:href=&quot;@{/detail/common/1}&quot;&gt;飞驰人生&lt;/a&gt;&lt;/li&gt;&#10;        &lt;li&gt;&lt;a th:href=&quot;@{/detail/common/2}&quot;&gt;夏洛特烦恼&lt;/a&gt;&lt;/li&gt;&#10;      &lt;/ul&gt;&#10;    &lt;/div&gt;&#10;    &lt;div sec:authorize=&quot;hasAuthority('Role_vip')&quot;&gt;&#10;      &lt;h3&gt;&#10;        Vip专享&#10;      &lt;/h3&gt;&#10;      &lt;ul&gt;&#10;        &lt;li&gt;&lt;a th:href=&quot;@{/detail/vip/1}&quot;&gt;速度与激情&lt;/a&gt;&lt;/li&gt;&#10;        &lt;li&gt;&lt;a th:href=&quot;@{/detail/vip/2}&quot;&gt;猩球崛起&lt;/a&gt;&lt;/li&gt;&#10;      &lt;/ul&gt;&#10;    &lt;/div&gt;&#10;    &lt;/body&gt;&#10;    &lt;/html&gt;">
  </outline>
</outline>
  </body>
</opml>
